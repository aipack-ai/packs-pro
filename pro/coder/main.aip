# Before All

```lua
local u_before_all   = require("utils_before_all")

local new_inputs, options, err = u_before_all.run_before_all(inputs)
if err then return aip.flow.skip(err) end

return aip.flow.before_all_response({
    inputs  = new_inputs,
    options = options
})
```

# Data

```lua
local p_utils  = require("utils_data")

-- This is the input format (.base, and the .working_refs)
local base, working_refs = input.base, input.working_refs

-- Compute new_context_refs
local new_context_refs = nil 
if working_refs and #working_refs > 1 then
    local working_set = {}
    for _, ref in ipairs(working_refs) do
        working_set[ref.path] = true
    end

    new_context_refs = {}
    for _, ref in ipairs(base.context_refs) do
        if not working_set[ref.path] then
            table.insert(new_context_refs, ref)
        end
    end
else 
    new_context_refs = base.context_refs -- by default
end


-- Compute total size
local total_size = 0
local all_refs  = {
  base.knowledge_refs or {}, -- making sure it is not nil, otherwise, loop below stops
  new_context_refs or {},
  working_refs or {}
}

for _, file_list in ipairs(all_refs) do
  for _, file in ipairs(file_list) do
    total_size = total_size + file.size
  end
end

-- Check that not more than max
local max_files_size_b = base.max_files_size_kb * 1000
if total_size > max_files_size_b then
    local msg = "Max files size reached."
    msg = msg .. "\n Actual size: " .. aip.text.format_size(total_size)
    msg = msg .. "\n    Max size: " .. aip.text.format_size(max_files_size_b)
    return aip.flow.skip(msg)
end

-- extract attachments (nil if empty or undefined)
local attachments = nil
if base.attachments and #base.attachments > 0 then
  attachments = base.attachments
end

-- Save the prompt_file_paths
local prompt_files_content = "====\n\n"
if attachments then
    prompt_files_content = prompt_files_content .. "# Attachments" .. "\n"
    for _, att in ipairs(attachments) do
        prompt_files_content = prompt_files_content .. "\n- " .. att.file_source
    end
    prompt_files_content = prompt_files_content .. "\n\n"
end
prompt_files_content = prompt_files_content .. "# Knowledge Files" .. "\n\n" .. p_utils.file_refs_to_md(base.knowledge_refs) .. "\n\n"
prompt_files_content = prompt_files_content .. "# Context Files"   .. "\n\n" .. p_utils.file_refs_to_md(new_context_refs) .. "\n\n"
prompt_files_content = prompt_files_content .. "# Working Files"   .. "\n\n" .. p_utils.file_refs_to_md(working_refs) .. "\n\n"
prompt_files_content = prompt_files_content .. "# Struture Files"  .. "\n\n" .. p_utils.file_refs_to_md(base.structure_refs, "(Only file paths, not their content)") .. "\n\n"
aip.file.append(base.prompt_file_paths, prompt_files_content)


-- Augment the base
base.knowledge_files = p_utils.load_file_refs(CTX.WORKSPACE_DIR, base.knowledge_refs)
base.context_files   = p_utils.load_file_refs(base.base_dir, new_context_refs)
base.working_files   = p_utils.load_file_refs(base.base_dir, working_refs)

-- Add time if available
if aip.time.weekday_local and aip.time.now_iso_local then
    base.now_local = aip.time.now_iso_local() .. " (" .. aip.time.weekday_local() .. ")"
end
-- Print info
local knowledge_file_count = tostring(base.knowledge_files and #base.knowledge_files or 0)
local working_file_count = tostring(base.working_files and #base.working_files or 0)
local context_file_count = tostring(base.context_files and #base.context_files or 0)
local task_info = "Context Files: " .. context_file_count .. " | Working Files: " .. working_file_count .. " | Knowledge Files: " .. knowledge_file_count
if attachments then
    task_info = task_info .. " | Attachments: " .. #attachments
end
-- Disable, because now it won't include the attachments size
-- if total_size > 0 then
--     local total_size_fmt = aip.text.format_size(total_size, {trim = true})
--     task_info = task_info .. "\nTotal files size: " .. total_size_fmt
-- end
if base.now_local then
   task_info = task_info .. "\nTime: " .. base.now_local
end
print(task_info)



-- The augmented base becomes the data.
return aip.flow.data_response({
    data        = base,
    attachments = base.attachments,
})
```

# System `cache = {{data.cache_pre_prompts}}`

You are a senior developer expert who has deep expertise in many languages and creates production-grade quality code (simple and scalable).

The user instruction will ask you to review/update the existing code or create new code if no existing code is provided.

When the language cannot be inferred from the user or context provided, assume the question is for the {{data.default_language}}` programming language. Otherwise, use the language inferred from the context or user instructions.

When you generate markdown, make sure to leave one empty line before and after any heading, except if the heading is the first line of the file.

When existing code, do not perform reformatting or make unnecessary changes unless explicitly requested by the user or specified in the user/system knowledge or instructions.

When providing text or comments, do not use em dash (—) as a sentence part seprator, use a comma, semi-column, or period as appropriate. Do not use dashes as sentence separators, never.

# User `cache = {{data.cache_pre_prompts}}`

{{#if data.instructions.file_content_change}}
{{data.instructions.file_content_change}}
{{/if}}

# User `cache = {{data.cache_pre_prompts}}`

Here are some some general language best practices to follow when providing code.

## Languages best practices

### Markdown 

- Make sure to have empty line after any heading (with one or more `#` character)
- Except if told otherwise, use `-` for bullet points (rather than `*`). 

### HTML

- Keep the tags simple, and use modern techniques that work in browsers that are -2 years old.
- Use CSS class names as IDs rather than element IDs when creating new code.
    - However, do not change the code unless explicitly asked by the user.

### JavaScript

- Use the web module loading so that we can use modern JavaScript.
- When drawing, try to use Canvas 2D.
- Use standard fetch to retrieve JSON.

### CSS

- Try to use CSS Grid when possible.
- When files are `.pcss`, assume there is a PCSS plugin nested, so that you do not get confused, and keep the nesting appropriately.

### General

- When you provide the code, make sure to return it in the relevant Markdown code block, with the correct language, and include the file path line.
- Only provide the files that need to be corrected, but make sure each file you return includes all of the code for that file.
- Make sure all file names are lowercase, and if they have multiple words, separate them with `-`.
- When you provide an answer with bullet points, use the `-` character for bullet points (in short, use only 7-bit ASCII characters).
- When you provide file paths and names in Markdown text, put them in backticks, like `some/path/to/file.rs`.
- Do not remove code regions unless explicitly asked.
- When you update code, types, functions or code body, make sure any related adjacent comment is kept in sync wwith the new logic / type. Follow the current function and type comment pattern.

---

{{#if data.instructions.suggest_commit}}
{{data.instructions.suggest_commit}}
{{/if}}

--- 

When ask to update some files, if you do not have have some files that you should have, answer the missing files under a `<missing_files>` tag like for example: 

<missing_files>
<mf_message>
HERE_THE_MESSAGE_TO_THE_USER
</mf_message>
<mf_files>
  - FILE_PATH
  - FILE_PATH
  - ...
</mf_files>
</missing_files>

Note that sometime, the user will ask to create new files, so, that's ok, you can create them. 

# User `cache = {{data.cache_knowledge_files}}`

{{#if data.knowledge_files}}

Here are some important knowledge, guidelines, and best practices I like you to follow. Make sure you respect them when providing code. Each knowledge file is under the `<KNOWLEDGE_FILE>` tag with the file path as `file=...`

{{#each data.knowledge_files}}

<KNOWLEDGE_FILE file_path="{{this.path}}">
````{{this.ext}}
{{this.content}}
````
</KNOWLEDGE_FILE>

{{/each}}

{{/if}}

# User `cache = false`

{{#if data.structure_refs}}

Here are the file structure of this project. Do not edit/change file you do not have source for. 
Those are for your reference, in case there are referred somewhere. 

{{#each data.structure_refs}}
- {{this.path}}
{{/each}}

{{/if}}


# User `cache = {{data.cache_context_files}}`

{{#if data.context_files}}

Now, here are the context source files that are related to the work to be done.

{{#each data.context_files}}

<CONTEXT_FILE file_path="{{this.path}}">
````{{this.ext}}
{{this.content}}
````
</CONTEXT_FILE>

{{/each}}

Only write the files that need to be rewritten based on the user instruction.

{{/if}}

# User

{{#if data.working_files}}

Here is the working files you need to work on.

{{#each data.working_files}}
<WORKING_FILE file_path="{{this.path}}">
````{{this.ext}}
{{this.content}}
````
</WORKING_FILE>

{{/each}}

Only write the files that need to be rewritten based on the user instruction, and make sure those files have their full content.

{{/if}}

# User

{{#if data.include_second_part}}

User's content and/or previous answer.

Here is some context and/or your previous answer:

{{data.second_part}}

{{/if}}

# User

{{#if data.inst}}
Here are my instruction for this work:

{{data.inst}}

{{/if}}

{{#if data.now_local}}
Here is today local date / time if user ask to do something with it: 
{{data.now_local}}
{{/if}}

**Important additional instruction:**

- This prevents formatting issues if the file itself contains triple backticks.
- **Never remove or alter existing comments. (except if explictly asked by the user)**  
  Comments must be preserved *verbatim*, including spacing, indentation, and placement, even if they appear redundant or outdated.
- Do **not** add trivial explanatory comments (e.g., explaining imports, renames, or obvious changes).  
  Only add comments that provide meaningful context, design rationale, or structure (such as region markers or explanations of non-obvious logic).
- **Comment preservation overrides any cleanup, refactor, or reformatting rule.**

# Output

```lua
local CONST = require("consts")

local u_output = require("utils_output")
local u_tmpl = require("utils_tmpl")

local base_dir = data.base_dir

local ai_content = ai_response.content

-- By default, the second part is the ai_content
local second_part = ai_content

-- Info lines
local info_lines = u_output.build_info_lines(ai_response, data)

-- === Write to the ai_content_for_raw
local ai_content_for_raw = "====\n" .. info_lines .. "\n\n" .. ai_content .. "\n\n"
aip.file.append(data.ai_responses_for_raw_path, ai_content_for_raw)

-- === Write to the src file
local files_changed = {}
local files_changes_failed = {}
second_part, files_changed, files_changes_failed = u_output.apply_changes(ai_content, data)

-- === Process files_changes_failed
u_output.handle_failed_changes(files_changes_failed, data)

-- === Process the eventual content to pin/print
u_output.process_ui_directives(second_part)

-- === Append to the second_part to ai_content_for_prompt file
second_part = aip.text.trim_start(second_part)
local ai_content_for_prompt = "====\n" .. info_lines .. "\n\n" .. second_part .. "\n"
aip.file.append(data.ai_responses_for_prompt_path, ai_content_for_prompt)

-- === Update the prompt file
local ai_content_for_prompt = aip.file.load(data.ai_responses_for_prompt_path).content
local prompt_content = u_tmpl.sync_prompt(data.first_part, ai_content_for_prompt)

aip.file.save(data.prompt_path, prompt_content)

-- print("Executed from your @coder prompt file:" .. data.prompt_file_rel_path)

-- === Build the Response
local response = nil

if #files_changes_failed == 0 then
	response = "✅ "
else
	response = "⚠ "
end

if data.write_mode then
    if #files_changed == 0 then
        response = response .. "No File changed."
        response = response .. "\nCheck prompt file for more AI answer."
        response = response .. "\nPrompt file:\n→ " .. data.prompt_file_rel_path        
    else 
        local file_txt = "file"
        if #files_changed > 1 then
            file_txt = "files"
        end
        response = response .. "" .. #files_changed .. " " .. file_txt .. " changed:\n"
        response = response .. "→ " .. table.concat(files_changed, "\n→ ")
    end
else 
    response = response .. "\nPrompt File has been updated with AI Response. Prompt file:"
    response = response .. "\n→ " .. data.prompt_file_rel_path
end

aip.task.pin("completed", 0, {
	label   = CONST.LABEL_COMPLETED,
	content = response
})

if data.write_mode then 
 	response = response .. "\n\nCheck prompt file for more AI answer. Prompt file:"
  response = response .. "\n→ " .. data.prompt_file_rel_path
else
  response = response .. "\nPrompt File has been updated with AI Response. Prompt file:"
  response = response .. "\n→ " .. data.prompt_file_rel_path
end

return response
```
