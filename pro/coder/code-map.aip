# Before All

```lua
local _cm = require("code_map")

-- Extract config and code_map data
local sub_agent_input = inputs[1]
local code_map_config = _cm.extract_code_map_config(sub_agent_input)

-- Load all code maps
local loaded_maps = {}
for _, mdef in ipairs(code_map_config.map_defs) do
	loaded_maps[mdef.file_path] = _cm.load_code_map_file(mdef.file_path)
end

-- Build before all data
local files_to_process = {}

local to_process_count = 0

local file_status_by_path = {}

for _, mdef in ipairs(code_map_config.map_defs) do
	local map_data = loaded_maps[mdef.file_path]
	local file_map = map_data.file_map
	local map_files = aip.file.list(mdef.globs)
	
	for _, orig_file in ipairs(map_files) do
		local fpath = orig_file.path
		if not file_status_by_path[fpath] then
			file_status_by_path[fpath] = {
				file = orig_file,
				maps_to_process_for = {},
				maps_up_to_date_for = {},
				map_names = {},
				cached_data = nil
			}
		end
		local fstatus = file_status_by_path[fpath]
		if mdef.name then
			table.insert(fstatus.map_names, mdef.name)
		end

		local file_map_file = file_map[fpath]
		if file_map_file and file_map_file.mtime >= orig_file.mtime then
			fstatus.maps_up_to_date_for[mdef.file_path] = true
			fstatus.cached_data = file_map_file
		else
			fstatus.maps_to_process_for[mdef.file_path] = true
			fstatus.cached_data = file_map_file or fstatus.cached_data
		end
	end
end

for fpath, fstatus in pairs(file_status_by_path) do
	local needs_processing = next(fstatus.maps_to_process_for) ~= nil
	if needs_processing then
		to_process_count = to_process_count + 1
		table.insert(files_to_process, {
			_display      = fpath,
			file          = fstatus.file,
			file_map_file = fstatus.cached_data,
			map_names     = fstatus.map_names,
			maps_to_process_for = fstatus.maps_to_process_for,
			maps_up_to_date_for = fstatus.maps_up_to_date_for
		})
	end
end

if to_process_count == 0 then
	aip.run.pin("status", 1, "Code map up to date, nothing to do")
else 
	aip.run.pin("status", 1, "to_process_count " .. to_process_count .. " files")
end

return aip.flow.before_all_response({
	options    = {
		model             = code_map_config.model,
		input_concurrency = code_map_config.input_concurrency
	},
	inputs     = files_to_process,
	before_all = {
		sub_agent_input    = sub_agent_input,
		to_process_count   = #files_to_process,
		code_map_config    = code_map_config,
		loaded_maps        = loaded_maps
	}
})
```

# Data

```lua
if input then
	local file = aip.file.load(input.file.path)
	local file_map_file_txt = nil
	if input.file_map_file then
			file_map_file_txt = aip.json.stringify_pretty(input.file_map_file)
	end
	
	return {
		_display = file.path,
		file = file,
		file_map_file_txt = file_map_file_txt
	}
else
	return nil
end

```

# Instruction

{{#if data.file}}

Below is the file content (under the `FILE_CONTENT` tag) that you need to extract some information

Respond with a `FILE_INFO` tag like 
<FILE_INFO>
_file_raw_json_format_
</FILE_INFO>

Here is the `_file_raw_json_format_` schema 

```typescript
{
	file_path: string,
	summary: string,             // short summary of the file, it's responsibility/purpose
	when_to_use: string,         // concise information of when this file should be included in the context
	public_types?: string[],     // list of public types this file exposes (if any)
	public_functions?: string[], // list of public functions this file exposes (if any)
}
```

`_file_raw_json_format_` should jsut be the json, no need to put it in markdown codel bock. 

Here is the file content

<FILE_CONTENT file_path="{{data.file.path}}">
{{data.file.content}}
</FILE_CONTENT>


{{#if data.file_map_file_txt}}

Also, only give back the `FILE_INFO` tag if it is different from the previous one, see below (this way we do not update it if not needed). 

Here is the preview previous file info

<PREVIOUS_FILE_INFO>
{{data.file_map_file_txt}}
<PREVIOUS_FILE_INFO>

{{/if}}

{{/if}}

# Output

```lua
if ai_response then
	return {
		content  = ai_response.content,
		_display = "code map file updated for file:\n- " .. data.file.path
	}
else
	return nil
end

```

# After All

```lua
local _cm = require("code_map")

local code_map_config    = before_all.code_map_config
local loaded_maps        = before_all.loaded_maps

if before_all.to_process_count > 0 then 
	for i, output in ipairs(outputs) do
		local output_content = output.content
		local input_file = inputs[i].file
		local file_path = input_file.path
		
		local tag_map = aip.tag.extract_as_map(output_content, "FILE_INFO")
		
		if tag_map.FILE_INFO then
			local raw_content = tag_map.FILE_INFO.content
			raw_content = aip.md.outer_block_content_or_raw(raw_content)
			local ok, json_content_res = pcall(aip.json.parse, raw_content)
			if ok then
				json_content_res.mtime = input_file.mtime
				
				for map_path, _ in pairs(inputs[i].maps_to_process_for) do
					loaded_maps[map_path].file_map[file_path] = json_content_res
				end
				for map_path, _ in pairs(inputs[i].maps_up_to_date_for) do
					loaded_maps[map_path].file_map[file_path] = json_content_res
				end
			else
				print("Error while parsing FILE_INFO json for file\n" .. file_path)
				print(output_content)
			end
			
		else
			print("No FILE_INFO tag for " .. file_path .. "\n(might match current info)")
		end
		
	end
	
	for map_path, map_data in pairs(loaded_maps) do
		local content = aip.json.stringify_pretty(map_data)
		aip.file.save(map_path, content)
	end
end

local code_map_file_paths = {}
for map_path, _ in pairs(loaded_maps) do
	table.insert(code_map_file_paths, map_path)
end

return {
	code_map_file_paths = code_map_file_paths
}

```


