
# Data

```lua
local _cm = require("code_map")
local _ac = require("auto_context")

aip.run.set_label("auto-context")

local sub_agent_input = input

-- === extract the auto_context_config
local auto_context_config   = _ac.extract_auto_context_config(sub_agent_input)

-- === Build helper_files if present
local helper_files = nil

if not is_null(auto_context_config.helper_globs) and #auto_context_config.helper_globs > 0 then
	helper_files = aip.file.list_load(auto_context_config.helper_globs)
end


-- === Show status
local context_globs = sub_agent_input.coder_params.context_globs
local context_files = aip.file.list(context_globs)
local context_files_size = 0
for _, cfile in ipairs(context_files) do
	context_files_size = context_files_size + cfile.size
end
local status_msg = _ac.pin_status(auto_context_config, {
	context_files_count = #context_files,
	context_files_size  = context_files_size,
	helper_files        = helper_files
})

-- === run code-map agent
-- Note: for now, just passthrough input (later will resolve code_map_model, and code_map_input_concurrency)
local code_map_agent_config = {
	named_maps = {
		{ 
			name = auto_context_config.map_name, 
			globs = auto_context_config.code_map_globs 
		}
	},
	model = auto_context_config.code_map_model,
	input_concurrency = auto_context_config.code_map_input_concurrency,
}
local code_map_input = aip.lua.merge({}, sub_agent_input, {agent_config = code_map_agent_config})
-- print(code_map_input)
local code_map_res = aip.agent.run("code-map", {input = code_map_input})

local code_map_dir = sub_agent_input.coder_prompt_dir .. "/.cache/code-map"
local code_map_file_path = code_map_dir .. "/" .. auto_context_config.map_name .. "-code-map.json"

-- === Extract code map 
local code_map        = _cm.load_code_map_file(code_map_file_path)

-- === Determine if we have a prompt
local user_prompt = sub_agent_input.coder_prompt
if not user_prompt or not user_prompt:find("%S") then
	local msg = "No prompt - skipping re-context step (only code-map done)"
	aip.run.pin("status", 2, msg)
	return aip.flow.skip("No prompt - skipping re-context step (only code-map done)")
end

-- === Extract base_files (the upper bound file set)
local available_files = aip.file.list(auto_context_config.code_map_globs)

-- === Extract c_files (the code map files info)
local c_files = {}
local file_map = code_map.file_map
for _, bfile in ipairs(available_files) do
	local cfile = file_map[bfile.path]
	if cfile then
		table.insert(c_files, cfile)
	end
end

-- === Build/Format the c_files_txt (md format)
-- Sort the c_files by mtime to help with caching
table.sort(c_files, function(a, b)
    if a.mtime == b.mtime then
        return a.file_path < b.file_path
    end
    return a.mtime < b.mtime
end)

-- now build the c_files_txt
local c_files_txt = ""
for _, cfile in ipairs(c_files) do
	local txt = "- " .. cfile.file_path .. "\n"
	txt = txt .. "    - Summary: " .. cfile.summary .. "\n"
	txt = txt .. "    - When To Use: " .. cfile.when_to_use .. "\n"
	if cfile.public_types and #cfile.public_types > 0 then
		txt = txt .. "    - Types: " .. table.concat(cfile.public_types, ", ")  .. "\n"
	end
	if cfile.public_functions and #cfile.public_functions > 0 then
		txt = txt .. "    - Functions: " .. table.concat(cfile.public_functions, ", ")  .. "\n"
	end
	c_files_txt = c_files_txt .. txt .. "\n"
end


return aip.flow.data_response({
	data = {
		auto_context_config   = auto_context_config,
		user_prompt         = user_prompt,
		c_files_txt         = c_files_txt,
		c_files_count       = #c_files,
		helper_files        = helper_files,
		context_globs       = context_globs,
		context_files_count = #context_files,
		context_files_size  = context_files_size,
		mode                = auto_context_config.mode
	},
	options = {
		model = auto_context_config.model
	}
})

```

# System

Your goals it to look at the user prompt, and the files and their description and determine the one that are needed for that prompt. 

The user will give you: 

- The answer format that you need to follow
- The available files with their information
- The possible file helpers
- and the user prompt

# Instruction

First, when responding, put the result under a `needed_files` tag, like

<needed_files>
_needed_files_as_json_array_
</needed_files>

Also, after this tag, but another tag `selection_reasoning` explaining in a concise maner why those files were selected. 

<selection_reasoning>
_concise_reasoning_as_text_
</selection_reasoning>

If/when appropriate, for the `_concise_reasoning_as_text_` have few bullet points (minimum formating, no bold/italic, and `-` as bullet). Maximum 3 bullet points, just high level reasoning explanation (do not have bullets per file, just overall reasoning summary). 

--- 

Here are the available files and their descriptions

<available_files>
{{data.c_files_txt}}
</available_files>

---

{{#if data.helper_files}}

Also, here are some other files that help termine which file might be needed from the available_files. 

{{#each data.helper_files}}
<HELPER_FILE name="{{this.path}}">
{{this.content}}
</HELPER_FILE>
{{/each}}

--- 
{{/if}}

Here is the user prompt:

<user_prompt>
{{data.user_prompt}}
</user_prompt>

# Output

```lua
local _ac = require("auto_context")

local mode = data.auto_context_config.mode

local res_map = aip.tag.extract_as_map(ai_response.content, {"needed_files", "selection_reasoning"})

local needed_files = aip.json.parse(res_map.needed_files.content)
local selection_reasoning = res_map.selection_reasoning.content

local new_context_globs = {}
	-- TODO: need to add the negative globs
if mode == "reduce" then
	new_context_globs = needed_files
else -- augment
	-- Init the new_context_globs, 
	table.move(data.context_globs, 1, #data.context_globs, 
		         1, new_context_globs)
	
	-- build the orig_context_file_map to see what is already in teh glob
	orig_context_files = aip.file.list(data.context_globs)
	local orig_context_file_map = {}
	for _, file in ipairs(orig_context_files) do
		orig_context_file_map[file.path] = true
	end
	
	-- buid the addl_files list
	local addl_files = {}
	for _, file_path in ipairs(needed_files) do
		if not orig_context_file_map[file_path] then
			table.insert(addl_files, file_path)
		end
	end
	
	-- extends the new_context_globs
	table.move(
		addl_files, 1, #addl_files,
    #new_context_globs + 1, new_context_globs
	)
end

local status_msg = _ac.pin_status(data.auto_context_config, {
	context_files_count = data.context_files_count,
	context_files_size  = data.context_files_size,
	new_context_globs   = new_context_globs,
	reason              = selection_reasoning,
	helper_files        = data.helper_files
})

return {
	_display = "" .. data.context_files_count .. " context files",
	coder_params = { context_globs = new_context_globs },
}
```
