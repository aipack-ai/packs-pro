
# Data

```lua
local _cm = require("code_map")
local _ac = require("auto_context")

aip.run.set_label("auto-context")

local sub_agent_input = input

-- === extract the auto_context_config
local auto_context_config   = _ac.extract_auto_context_config(sub_agent_input)

-- === Build helper_files if present
local helper_files = nil

if not is_null(auto_context_config.helper_globs) and #auto_context_config.helper_globs > 0 then
	helper_files = aip.file.list_load(auto_context_config.helper_globs)
end


-- === Show status
local context_globs = sub_agent_input.coder_params.context_globs
local context_files = aip.file.list(context_globs)
local context_files_size = 0
for _, cfile in ipairs(context_files) do
	context_files_size = context_files_size + cfile.size
end

-- === Compute knowledge file stats (if knowledge enabled)
local knowledge_globs = auto_context_config.knowledge_globs
local knowledge_files = {}
local knowledge_files_size = 0
if auto_context_config.knowledge and knowledge_globs then
	knowledge_files = aip.file.list(knowledge_globs)
	for _, kfile in ipairs(knowledge_files) do
		knowledge_files_size = knowledge_files_size + kfile.size
	end
end

_ac.pin_status(auto_context_config, {
	context_files_count = #context_files,
	context_files_size  = context_files_size,
	helper_files        = helper_files,
	knowledge_files_count = #knowledge_files,
	knowledge_files_size  = knowledge_files_size,
})

-- === run code-map agent
-- Note: for now, just passthrough input (later will resolve code_map_model, and code_map_input_concurrency)
local named_maps = {
	{ 
		name = auto_context_config.map_name, 
		globs = auto_context_config.code_map_globs 
	}
}

-- Add knowledge named map if knowledge is enabled
if auto_context_config.knowledge and knowledge_globs then
	table.insert(named_maps, {
		name = "knowledge",
		globs = knowledge_globs
	})
end

local code_map_agent_config = {
	named_maps = named_maps,
	model = auto_context_config.code_map_model,
	input_concurrency = auto_context_config.code_map_input_concurrency,
}
local code_map_input = aip.lua.merge({}, sub_agent_input, {agent_config = code_map_agent_config})
-- print(code_map_input)
local code_map_res = aip.agent.run("code-map", {input = code_map_input})

local code_map_dir = sub_agent_input.coder_prompt_dir .. "/.cache/code-map"
local code_map_file_path = code_map_dir .. "/" .. auto_context_config.map_name .. "-code-map.json"

-- === Extract code map 
local code_map        = _cm.load_code_map_file(code_map_file_path)

-- === Extract knowledge code map (if enabled)
local knowledge_code_map = nil
if auto_context_config.knowledge and knowledge_globs then
	local knowledge_code_map_file_path = code_map_dir .. "/knowledge-code-map.json"
	knowledge_code_map = _cm.load_code_map_file(knowledge_code_map_file_path)
end

-- === Determine if we have a prompt
local user_prompt = sub_agent_input.coder_prompt
if not user_prompt or not user_prompt:find("%S") then
	local msg = "No prompt - skipping re-context step (only code-map done)"
	aip.run.pin("status", 2, msg)
	return aip.flow.skip("No prompt - skipping re-context step (only code-map done)")
end

-- === Extract base_files (the upper bound file set)
local available_files = aip.file.list(auto_context_config.code_map_globs)

-- === Extract c_files (the code map files info)
local c_files = {}
local file_map = code_map.file_map
for _, bfile in ipairs(available_files) do
	local cfile = file_map[bfile.path]
	if cfile then
		table.insert(c_files, cfile)
	end
end

-- === Build/Format the c_files_txt (md format)
-- Sort the c_files by mtime to help with caching
table.sort(c_files, function(a, b)
    if a.mtime == b.mtime then
        return a.file_path < b.file_path
    end
    return a.mtime < b.mtime
end)

-- now build the c_files_txt
local c_files_txt = ""
for _, cfile in ipairs(c_files) do
	local txt = "- " .. cfile.file_path .. "\n"
	txt = txt .. "    - Summary: " .. cfile.summary .. "\n"
	txt = txt .. "    - When To Use: " .. cfile.when_to_use .. "\n"
	if cfile.public_types and #cfile.public_types > 0 then
		txt = txt .. "    - Types: " .. table.concat(cfile.public_types, ", ")  .. "\n"
	end
	if cfile.public_functions and #cfile.public_functions > 0 then
		txt = txt .. "    - Functions: " .. table.concat(cfile.public_functions, ", ")  .. "\n"
	end
	c_files_txt = c_files_txt .. txt .. "\n"
end

-- === Build/Format the k_files_txt (md format) for knowledge files
local k_files_txt = ""
local k_files_count = 0
if auto_context_config.knowledge and knowledge_code_map then
	local available_knowledge_files = aip.file.list(knowledge_globs)
	local k_files = {}
	local k_file_map = knowledge_code_map.file_map
	for _, kfile in ipairs(available_knowledge_files) do
		local mapped = k_file_map[kfile.path]
		if mapped then
			table.insert(k_files, mapped)
		end
	end

	-- Sort by mtime for caching
	table.sort(k_files, function(a, b)
		if a.mtime == b.mtime then
			return a.file_path < b.file_path
		end
		return a.mtime < b.mtime
	end)

	k_files_count = #k_files
	for _, kfile in ipairs(k_files) do
		local txt = "- " .. kfile.file_path .. "\n"
		txt = txt .. "    - Summary: " .. kfile.summary .. "\n"
		txt = txt .. "    - When To Use: " .. kfile.when_to_use .. "\n"
		if kfile.public_types and #kfile.public_types > 0 then
			txt = txt .. "    - Types: " .. table.concat(kfile.public_types, ", ")  .. "\n"
		end
		if kfile.public_functions and #kfile.public_functions > 0 then
			txt = txt .. "    - Functions: " .. table.concat(kfile.public_functions, ", ")  .. "\n"
		end
		k_files_txt = k_files_txt .. txt .. "\n"
	end
end

return aip.flow.data_response({
	data = {
		auto_context_config   = auto_context_config,
		user_prompt         = user_prompt,
		c_files_txt         = c_files_txt,
		c_files_count       = #c_files,
		k_files_txt         = k_files_txt,
		k_files_count       = k_files_count,
		knowledge_enabled   = auto_context_config.knowledge,
		helper_files        = helper_files,
		context_globs       = context_globs,
		context_files_count = #context_files,
		context_files_size  = context_files_size,
		knowledge_globs     = knowledge_globs,
		knowledge_files_count = #knowledge_files,
		knowledge_files_size  = knowledge_files_size,
		mode                = auto_context_config.mode,
	},
	options = {
		model = auto_context_config.model
	}
})

```

# System

Your goal is to look at the user prompt, and the files and their descriptions and determine the ones that are needed for that prompt. 

The user will give you: 

- The answer format that you need to follow
- The available files with their information
- The possible file helpers
- and the user prompt

# Instruction

{{#if data.knowledge_enabled}}
You will select files from two categories: **context files** and **knowledge files**.

First, for context files, put the result under a `needed_context_files` tag:

<needed_context_files>
_needed_context_files_as_json_array_
</needed_context_files>

Then, put the context reasoning under a `context_reasoning` tag:

<context_reasoning>
_concise_reasoning_as_text_
</context_reasoning>

Then, for knowledge files, put the result under a `needed_knowledge_files` tag:

<needed_knowledge_files>
_needed_knowledge_files_as_json_array_
</needed_knowledge_files>

Then, put the knowledge reasoning under a `knowledge_reasoning` tag:

<knowledge_reasoning>
_concise_reasoning_as_text_
</knowledge_reasoning>

{{else}}
First, when responding, put the result under a `needed_context_files` tag, like

<needed_context_files>
_needed_context_files_as_json_array_
</needed_context_files>

Also, after this tag, put another tag `context_reasoning` explaining in a concise manner why those files were selected. 

<context_reasoning>
_concise_reasoning_as_text_
</context_reasoning>

{{/if}}
If/when appropriate, for the `_concise_reasoning_as_text_` have few bullet points (minimum formatting, no bold/italic, and `-` as bullet). Maximum 3 bullet points, just high level reasoning explanation (do not have bullets per file, just overall reasoning summary). 

--- 

Here are the available context files and their descriptions

<available_context_files>
{{data.c_files_txt}}
</available_context_files>

{{#if data.knowledge_enabled}}

---

Here are the available knowledge files and their descriptions

<available_knowledge_files>
{{data.k_files_txt}}
</available_knowledge_files>

{{/if}}

---

{{#if data.helper_files}}

Also, here are some other files that help termine which file might be needed from the available_files. 

{{#each data.helper_files}}
<HELPER_FILE name="{{this.path}}">
{{this.content}}
</HELPER_FILE>
{{/each}}

--- 
{{/if}}

Here is the user prompt:

<user_prompt>
{{data.user_prompt}}
</user_prompt>

# Output

```lua
local _ac = require("auto_context")

local mode = data.auto_context_config.mode

local tag_names = {"needed_context_files", "context_reasoning"}
if data.knowledge_enabled then
	table.insert(tag_names, "needed_knowledge_files")
	table.insert(tag_names, "knowledge_reasoning")
end

local res_map = aip.tag.extract_as_map(ai_response.content, tag_names)

local needed_context_files = aip.json.parse(res_map.needed_context_files.content)
local context_reasoning = res_map.context_reasoning.content

local new_context_globs = {}
	-- TODO: need to add the negative globs
if mode == "reduce" then
	new_context_globs = needed_context_files
else -- augment
	-- Init the new_context_globs, 
	table.move(data.context_globs, 1, #data.context_globs, 
		         1, new_context_globs)
	
	-- build the orig_context_file_map to see what is already in teh glob
	orig_context_files = aip.file.list(data.context_globs)
	local orig_context_file_map = {}
	for _, file in ipairs(orig_context_files) do
		orig_context_file_map[file.path] = true
	end
	
	-- buid the addl_files list
	local addl_files = {}
	for _, file_path in ipairs(needed_context_files) do
		if not orig_context_file_map[file_path] then
			table.insert(addl_files, file_path)
		end
	end
	
	-- extends the new_context_globs
	table.move(
		addl_files, 1, #addl_files,
    #new_context_globs + 1, new_context_globs
	)
end

-- === Process knowledge selection
local new_knowledge_globs = nil
local knowledge_reasoning = nil
if data.knowledge_enabled and res_map.needed_knowledge_files then
	local needed_knowledge_files = aip.json.parse(res_map.needed_knowledge_files.content)
	new_knowledge_globs = needed_knowledge_files -- always "reduce" for knowledge
	if res_map.knowledge_reasoning then
		knowledge_reasoning = res_map.knowledge_reasoning.content
	end
end

_ac.pin_status(data.auto_context_config, {
	context_files_count = data.context_files_count,
	context_files_size  = data.context_files_size,
	new_context_globs   = new_context_globs,
	reason              = context_reasoning,
	helper_files        = data.helper_files,
	knowledge_files_count = data.knowledge_files_count,
	knowledge_files_size  = data.knowledge_files_size,
	new_knowledge_globs   = new_knowledge_globs,
	knowledge_reason      = knowledge_reasoning,
})

local coder_params = { context_globs = new_context_globs }
if new_knowledge_globs then
	coder_params.knowledge_globs = new_knowledge_globs
end

return {
	_display = "" .. data.context_files_count .. " context files",
	coder_params = coder_params,
}
```
